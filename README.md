## rishabSort Sorting Algorithm

This is my custom integer-sorting algorithm, and I built it to adapt itself to whatever data you give it. I call it **rishabSort**, and here’s the gist: it first checks if the numbers span a small range—if so, it jumps into counting sort for true linear-time performance. If the range is large, I build a frequency map and either sort just the unique keys or peel off any what I like to call "heavy hitter" values (those that appear  more frequently than the rest) in linear time. Next, I find the narrowest numeric interval that covers most of the remaining elements and perform a localized counting sort on that block, leaving only a handful of outliers to a standard comparison sort. Finally, I merge these sorted chunks in a single pass. In practical scenarios with tight ranges, lots of duplicates, or skewed distributions my algorithm runs in Θ(n), with a guaranteed O(nlog(n)) in the worst-case fallback.
