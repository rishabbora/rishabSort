## rishabSort

This is my custom integer-sorting algorithm, and I built it to adapt itself to whatever data you give it. I call it **rishabSort**, and here’s the gist: it first checks if the numbers span a small range—if so, it jumps into counting sort for true linear-time performance. If the range is large, I build a frequency map and either sort just the unique keys or peel off any “heavy hitter” values (those that appear way more often than the rest) in linear time. Next, I find the narrowest numeric interval that covers most of the remaining elements and perform a localized counting sort on that block, leaving only a handful of outliers to a standard comparison sort. Finally, I merge these sorted chunks in a single pass. In practical scenarios—tight ranges, lots of duplicates, or skewed distributions—rishabSort runs in Θ(n), with a guaranteed O(n log n) worst-case fallback.
